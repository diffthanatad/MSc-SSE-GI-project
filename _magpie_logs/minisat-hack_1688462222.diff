--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -216,7 +216,7 @@
     watches[~c[1]].push(Watcher(cr, c[0]));
     if (c.learnt())/*auto*/{ learnts_literals += c.size();
 }/*auto*/
-    else/*auto*/{            clauses_literals += c.size();
+    else/*auto*/{            int         conflictC = 0;clauses_literals += c.size();
 }/*auto*/ }
 
 
@@ -365,9 +365,7 @@
                 if (level(var(q)) >= decisionLevel()){
                     pathC++;
                     CRef r = reason(var(q));
-                    if (r != CRef_Undef && ca[r].mark() == 3)/*auto*/{
-                        varBumpActivity(var(q));
-}/*auto*/
+                    
                 }else/*auto*/{
                     out_learnt.push(q);
 }/*auto*/
@@ -522,7 +520,7 @@
         }
     }
 
-    seen[var(p)] = 0;
+    
 }
 
 
@@ -585,7 +583,10 @@
                 if (value(c[k]) != l_False){
                     c[1] = c[k]; c[k] = false_lit;
                     watches[~c[1]].push(w);
-                    goto NextClause; }
+                    goto NextClause;
+                    while (i < end)/*auto*/{
+                    *j++ = *i++;
+}/*auto*/ }
 }/*auto*/
 
             // Did not find watch -- clause is unit under assignment:
@@ -691,7 +692,7 @@
     assert(decisionLevel() == 0);
 
     if (!ok || propagate() != CRef_Undef)/*auto*/{
-        return ok = false;
+        
 }/*auto*/
 
     if (nAssigns() == simpDB_assigns || (simpDB_props > 0))/*auto*/{
@@ -716,7 +717,7 @@
     rebuildOrderHeap();
 
     simpDB_assigns = nAssigns();
-    simpDB_props   = clauses_literals + learnts_literals;   // (shouldn't depend on stats really, but it will do for now)
+       // (shouldn't depend on stats really, but it will do for now)
 
     return true;
 }
@@ -755,12 +756,7 @@
             if (decisionLevel() == 0)/*auto*/{ return l_False;
 }/*auto*/
 
-            if (!luby_restart){
-                PUSH(TQ, trail.size(), 5000, tS);
-                if (conflicts > 10000 && LQ.size() == 50 && trail.size() > R * tS / 5000)/*auto*/{
-                    lS = 0, LQ.clear();
-}/*auto*/
-            }
+            
 
             learnt_clause.clear();
             analyze(confl, learnt_clause, backtrack_level);
@@ -976,7 +972,7 @@
         for (int i = 0; i < nVars(); i++)/*auto*/{ model[i] = value(i);
 }/*auto*/
     }else if (status == l_False && conflict.size() == 0)/*auto*/{
-        ok = false;
+        
 }/*auto*/
 
     cancelUntil(0);
@@ -1066,9 +1062,7 @@
         toDimacs(f, ca[clauses[i]], map, max);
 }/*auto*/
 
-    if (verbosity > 0)/*auto*/{
-        printf("Wrote %d clauses with %d variables.\n", cnt, max);
-}/*auto*/
+    
 }
 
 
