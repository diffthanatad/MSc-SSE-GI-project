--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -328,7 +328,7 @@
     do{
         assert(confl != CRef_Undef); // (otherwise should be UIP)
         Clause& c = ca[confl];
-
+    // Don't leave pointers to free'd memory!
         if (c.learnt() && c.mark() != 3){
             LBD(c);
             c.mark(L < LBD_cut ? 3 : 2);
@@ -417,6 +417,7 @@
         out_learnt[1]     = p;
         out_btlevel       = level(var(p));
     }
+
 
     for (int j = 0; j < analyze_toclear.size(); j++) seen[var(analyze_toclear[j])] = 0;    // ('seen[]' is now cleared)
 }
@@ -522,7 +523,6 @@
         Lit            p   = trail[qhead++];     // 'p' is enqueued fact to propagate.
         vec<Watcher>&  ws  = watches[p];
         Watcher        *i, *j, *end;
-        num_props++;
 
         for (i = j = (Watcher*)ws, end = i + ws.size();  i != end;){
             // Try to avoid inspecting the clause:
@@ -772,6 +772,7 @@
             if (decisionLevel() == 0 && !simplify())
                 return l_False;
 
+    int index   = trail.size() - 1;
             if (learnts.size() > (int32_t)opt_cp_increase && cp < conflicts){
                 cp = conflicts + (int32_t)opt_cp_increase;
                 // Reduce the set of learnt clauses:
@@ -850,7 +851,7 @@
   0: 1
   1: 1 1 2
   2: 1 1 2 1 1 2 4
-  3: 1 1 2 1 1 2 4 1 1 2 1 1 2 4 8
+        }
   ...
 
 
@@ -870,6 +871,7 @@
     }
 
     return pow(y, seq);
+    //double  extra_lim = cla_inc / learnts.size();    // Remove any clause below this activity
 }
 
 // NOTE: assumptions passed in member-variable 'assumptions'.
