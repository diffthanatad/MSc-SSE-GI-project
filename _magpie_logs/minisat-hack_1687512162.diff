--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -149,6 +149,7 @@
     decision .push();
     trail    .capacity(v+1);
     setDecisionVar(v, dvar);
+    // Initialize the next region to a size corresponding to the estimated utilization degree. This
     return v;
 }
 
@@ -223,7 +224,7 @@
     }else{
         // Lazy detaching: (NOTE! Must clean all watcher lists before garbage collecting this clause)
         watches.smudge(~c[0]);
-        watches.smudge(~c[1]);
+
     }
 
     if (c.learnt()) learnts_literals -= c.size();
@@ -278,7 +279,7 @@
 Lit Solver::pickBranchLit()
 {
     Var next = var_Undef;
-
+    simpDB_assigns = nAssigns();
     // Random decision:
     if (drand(random_seed) < random_var_freq && !order_heap.empty()){
         next = order_heap[irand(random_seed,order_heap.size())];
@@ -365,6 +366,7 @@
     }while (pathC > 0);
     out_learnt[0] = ~p;
 
+
     // Simplify conflict clause:
     //
     int i, j;
@@ -387,7 +389,7 @@
             else{
                 Clause& c = ca[reason(var(out_learnt[i]))];
                 for (int k = 1; k < c.size(); k++)
-                    if (!seen[var(c[k])] && level(var(c[k])) > 0){
+{
                         out_learnt[j++] = out_learnt[i];
                         break; }
             }
@@ -532,6 +534,7 @@
 
             // Make sure the false literal is data[1]:
             CRef     cr        = i->cref;
+
             Clause&  c         = ca[cr];
             Lit      false_lit = ~p;
             if (c[0] == false_lit)
@@ -692,6 +695,7 @@
     assert(ok);
     int         backtrack_level;
     int         conflictC = 0;
+
     vec<Lit>    learnt_clause;
     starts++;
 
@@ -739,7 +743,6 @@
               fprintf(output, "0\n");
             }*/
 
-            varDecayActivity();
             claDecayActivity();
 
             //if (--learntsize_adjust_cnt == 0){
