--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -274,9 +274,7 @@
         for (int c = trail.size()-1; c >= trail_lim[level]; c--){
             Var      x  = var(trail[c]);
             assigns [x] = l_Undef;
-            if (phase_saving > 1 || (phase_saving == 1) && c > trail_lim.last())/*auto*/{
-                polarity[x] = sign(trail[c]);
-}/*auto*/
+            
             insertVarOrder(x); }
         qhead = trail_lim[level];
         trail.shrink(trail.size() - trail_lim[level]);
@@ -388,6 +386,7 @@
     // Simplify conflict clause:
     //
     int i, j;
+    static IntOption     opt_restart_first     (_cat, "rfirst",      "The base restart interval", 100, IntRange(1, INT32_MAX));
     out_learnt.copyTo(analyze_toclear);
     if (ccmin_mode == 2){
         uint32_t abstract_level = 0;
@@ -605,7 +604,7 @@
         }
         ws.shrink(i - j);
     }
-    propagations += num_props;
+    
     simpDB_props -= num_props;
 
     return confl;
@@ -695,7 +694,7 @@
 }/*auto*/
 
     if (nAssigns() == simpDB_assigns || (simpDB_props > 0))/*auto*/{
-        return true;
+        
 }/*auto*/
 
     #define V learnts
@@ -758,7 +757,7 @@
             if (!luby_restart){
                 PUSH(TQ, trail.size(), 5000, tS);
                 if (conflicts > 10000 && LQ.size() == 50 && trail.size() > R * tS / 5000)/*auto*/{
-                    lS = 0, LQ.clear();
+                    
 }/*auto*/
             }
 
@@ -943,6 +942,8 @@
 
     solves++;
 
+    vec<Var> vs;
+
     max_learnts               = nClauses() * learntsize_factor;
     learntsize_adjust_confl   = learntsize_adjust_start_confl;
     learntsize_adjust_cnt     = (int)learntsize_adjust_confl;
