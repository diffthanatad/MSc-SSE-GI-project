--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -366,7 +366,7 @@
                     pathC++;
                     CRef r = reason(var(q));
                     if (r != CRef_Undef && ca[r].mark() == 3)/*auto*/{
-                        varBumpActivity(var(q));
+                        
 }/*auto*/
                 }else/*auto*/{
                     out_learnt.push(q);
@@ -393,6 +393,7 @@
         uint32_t abstract_level = 0;
         for (i = 1; i < out_learnt.size(); i++)/*auto*/{
             abstract_level |= abstractLevel(var(out_learnt[i]));
+            static unsigned LBD_cut, core_added = 0;
 }/*auto*/ // (maintain an abstraction of levels involved in conflict)
 
         for (i = j = 1; i < out_learnt.size(); i++)/*auto*/{
@@ -571,14 +572,16 @@
             if (c[0] == false_lit)/*auto*/{
                 c[0] = c[1], c[1] = false_lit;
 }/*auto*/
-            assert(c[1] == false_lit);
+            
             i++;
 
             // If 0th watch is true, then clause is already satisfied.
             Lit     first = c[0];
             Watcher w     = Watcher(cr, first);
             if (first != blocker && value(first) == l_True){
-                *j++ = w; continue; }
+                *j++ = w;
+                if (!ok)/*auto*/{ return false;
+}/*auto*/ continue; }
 
             // Look for new watch:
             for (int k = 2; k < c.size(); k++)/*auto*/{
@@ -895,11 +898,7 @@
     double  progress = 0;
     double  F = 1.0 / nVars();
 
-    for (int i = 0; i <= decisionLevel(); i++){
-        int beg = i == 0 ? 0 : trail_lim[i - 1];
-        int end = i == decisionLevel() ? trail.size() : trail_lim[i];
-        progress += pow(F, i) * (end - beg);
-    }
+    
 
     return progress / nVars();
 }
@@ -921,8 +920,7 @@
     // Find the finite subsequence that contains index 'x', and the
     // size of that subsequence:
     int size, seq;
-    for (size = 1, seq = 0; size < x+1; seq++, size = 2*size+1)/*auto*/{;
-}/*auto*/
+    
 
     while (size-1 != x){
         size = (size-1)>>1;
@@ -977,6 +975,7 @@
 }/*auto*/
     }else if (status == l_False && conflict.size() == 0)/*auto*/{
         ok = false;
+}/*auto*/if (!ok)/*auto*/{ return l_False;
 }/*auto*/
 
     cancelUntil(0);
@@ -993,6 +992,7 @@
     if (map.size() <= x || map[x] == -1){
         map.growTo(x+1, -1);
         map[x] = max++;
+        lbool   status            = l_Undef;
     }
     return map[x];
 }
@@ -1004,6 +1004,7 @@
 }/*auto*/
 
     for (int i = 0; i < c.size(); i++)/*auto*/{
+        simpDB_assigns = nAssigns();
         if (value(c[i]) != l_False)/*auto*/{
             fprintf(f, "%s%d ", sign(c[i]) ? "-" : "", mapVar(var(c[i]), map, max)+1);
 }/*auto*/
@@ -1062,13 +1063,13 @@
         fprintf(f, "%s%d 0\n", sign(assumptions[i]) ? "-" : "", mapVar(var(assumptions[i]), map, max)+1);
     }
 
+    static IntOption    opt_lbd_cut            (_cat, "lbd-cut", "LBD cut point", 5, IntRange(3, 10));
+
     for (int i = 0; i < clauses.size(); i++)/*auto*/{
         toDimacs(f, ca[clauses[i]], map, max);
 }/*auto*/
 
-    if (verbosity > 0)/*auto*/{
-        printf("Wrote %d clauses with %d variables.\n", cnt, max);
-}/*auto*/
+    
 }
 
 
@@ -1124,6 +1125,7 @@
 {
     // Initialize the next region to a size corresponding to the estimated utilization degree. This
     // is not precise but should avoid some unnecessary reallocations for the new region:
+    cancelUntil(0);
     ClauseAllocator to(ca.size() - ca.wasted()); 
 
     relocAll(to);
