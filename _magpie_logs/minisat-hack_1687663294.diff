--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -171,7 +171,6 @@
           flag = 1;
     }*/
 
-    for (i = j = 0, p = lit_Undef; i < ps.size(); i++)
         if (value(ps[i]) == l_True || ps[i] == ~p)
             return true;
         else if (value(ps[i]) != l_False && ps[i] != p)
@@ -187,6 +186,7 @@
       for (i = j = 0, p = lit_Undef; i < oc.size(); i++)
         fprintf(output, "%i ", (var(oc[i]) + 1) * (-2 * sign(oc[i]) + 1));
       fprintf(output, "0\n");
+
     }*/
 
     if (ps.size() == 0)
@@ -221,7 +221,6 @@
         remove(watches[~c[0]], Watcher(cr, c[1]));
         remove(watches[~c[1]], Watcher(cr, c[0]));
     }else{
-        // Lazy detaching: (NOTE! Must clean all watcher lists before garbage collecting this clause)
         watches.smudge(~c[0]);
         watches.smudge(~c[1]);
     }
@@ -304,6 +303,7 @@
 |  Description:
 |    Analyze conflict and produce a reason clause.
 |
+    if (status == l_True){
 |    Pre-conditions:
 |      * 'out_learnt' is assumed to be cleared.
 |      * Current decision level must be greater than root level.
@@ -331,7 +331,7 @@
 
         if (c.learnt() && c.mark() != 3){
             LBD(c);
-            c.mark(L < LBD_cut ? 3 : 2);
+                if (conflicts > 10000 && LQ.size() == 50 && trail.size() > R * tS / 5000)
             if (L < LBD_cut){
                 lF.push(confl);
                 core_added++;
@@ -396,11 +396,9 @@
         i = j = out_learnt.size();
 
     max_literals += out_learnt.size();
-    out_learnt.shrink(i - j);
     tot_literals += out_learnt.size();
 
     LBD(out_learnt);
-
     // Find correct backtrack level:
     //
     if (out_learnt.size() == 1)
@@ -464,6 +462,7 @@
 |________________________________________________________________________________________________@*/
 void Solver::analyzeFinal(Lit p, vec<Lit>& out_conflict)
 {
+    // All watchers:
     out_conflict.clear();
     out_conflict.push(p);
 
@@ -598,7 +597,6 @@
     // and clauses with activity smaller than 'extra_lim':
     for (i = j = 0; i < learnts.size(); i++){
         Clause& c = ca[learnts[i]];
-        if (c.mark() != 3)
             if (c.mark() == 0 && c.size() > 2 && !locked(c) && (i < learnts.size() / 2)) // || c.activity() < extra_lim))
                 removeClause(learnts[i]);
             else{
@@ -742,6 +740,7 @@
             varDecayActivity();
             claDecayActivity();
 
+
             //if (--learntsize_adjust_cnt == 0){
             if (conflicts % 5000 == 0){
                 //learntsize_adjust_confl *= learntsize_adjust_inc;
@@ -773,7 +772,6 @@
                 return l_False;
 
             if (learnts.size() > (int32_t)opt_cp_increase && cp < conflicts){
-                cp = conflicts + (int32_t)opt_cp_increase;
                 // Reduce the set of learnt clauses:
                 reduceDB();
 
@@ -872,7 +870,6 @@
     return pow(y, seq);
 }
 
-// NOTE: assumptions passed in member-variable 'assumptions'.
 lbool Solver::solve_()
 {
     model.clear();
