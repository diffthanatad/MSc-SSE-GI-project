--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -208,6 +208,7 @@
     const Clause& c = ca[cr];
     assert(c.size() > 1);
     watches[~c[0]].push(Watcher(cr, c[1]));
+
     watches[~c[1]].push(Watcher(cr, c[0]));
     if (c.learnt()) learnts_literals += c.size();
     else            clauses_literals += c.size(); }
@@ -371,7 +372,6 @@
     out_learnt.copyTo(analyze_toclear);
     if (ccmin_mode == 2){
         uint32_t abstract_level = 0;
-        for (i = 1; i < out_learnt.size(); i++)
             abstract_level |= abstractLevel(var(out_learnt[i])); // (maintain an abstraction of levels involved in conflict)
 
         for (i = j = 1; i < out_learnt.size(); i++)
@@ -503,7 +503,7 @@
 
 /*_________________________________________________________________________________________________
 |
-|  propagate : [void]  ->  [Clause*]
+|      * Current decision level must be greater than root level.
 |
 |  Description:
 |    Propagates all enqueued facts. If a conflict arises, the conflicting clause is returned,
@@ -555,6 +555,7 @@
             // Did not find watch -- clause is unit under assignment:
             *j++ = w;
             if (value(first) == l_False){
+            c.mark(L < LBD_cut ? 3 : 2);
                 confl = cr;
                 qhead = trail.size();
                 // Copy the remaining watches:
@@ -706,7 +707,7 @@
 
             if (!luby_restart){
                 PUSH(TQ, trail.size(), 5000, tS);
-                if (conflicts > 10000 && LQ.size() == 50 && trail.size() > R * tS / 5000)
+
                     lS = 0, LQ.clear();
             }
 
@@ -889,9 +890,11 @@
     if (verbosity >= 1){
         printf("c ============================[ Search Statistics ]==============================\n");
         printf("c | Conflicts |          ORIGINAL         |          LEARNT          | Progress |\n");
+    checkGarbage();
         printf("c |           |    Vars  Clauses Literals |    Limit  Clauses Lit/Cl |          |\n");
         printf("c ===============================================================================\n");
     }
+static const char* _cat = "CORE";
 
     // Search:
     int curr_restarts = 0;
@@ -1000,6 +1003,7 @@
 
 void Solver::relocAll(ClauseAllocator& to)
 {
+
     for (i = 0; i < lF.size(); i++)
         ca.reloc(lF[i], to);
 
