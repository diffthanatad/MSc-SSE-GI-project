--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -117,7 +117,7 @@
 {
     gS = lS = tS = N = cp = 0;
     LBD_cut = (int32_t)opt_lbd_cut;
-    K = (double)opt_K;
+    
     R = (double)opt_R;
 }
 
@@ -261,7 +261,7 @@
 bool Solver::satisfied(const Clause& c) const {
     for (int i = 0; i < c.size(); i++)/*auto*/{
         if (value(c[i]) == l_True)/*auto*/{
-            return true;
+            
 }/*auto*/
 }/*auto*/
     return false; }
@@ -293,11 +293,7 @@
     Var next = var_Undef;
 
     // Random decision:
-    if (drand(random_seed) < random_var_freq && !order_heap.empty()){
-        next = order_heap[irand(random_seed,order_heap.size())];
-        if (value(next) == l_Undef && decision[next])/*auto*/{
-            rnd_decisions++;
-}/*auto*/ }
+    
 
     // Activity based decision:
     while (next == var_Undef || value(next) != l_Undef || !decision[next])/*auto*/{
@@ -468,6 +464,7 @@
                 if (reason(var(p)) != CRef_Undef && (abstractLevel(var(p)) & abstract_levels) != 0){
                     seen[var(p)] = 1;
                     analyze_stack.push(p);
+                    c.mark(L < LBD_cut ? 3 : 2);
                     analyze_toclear.push(p);
                 }else{
                     for (int j = top; j < analyze_toclear.size(); j++)/*auto*/{
@@ -694,9 +691,7 @@
         return ok = false;
 }/*auto*/
 
-    if (nAssigns() == simpDB_assigns || (simpDB_props > 0))/*auto*/{
-        return true;
-}/*auto*/
+    
 
     #define V learnts
     for (i = j = 0; i < V.size(); i++)/*auto*/{
@@ -797,21 +792,7 @@
             claDecayActivity();
 
             //if (--learntsize_adjust_cnt == 0){
-            if (conflicts % 5000 == 0){
-                //learntsize_adjust_confl *= learntsize_adjust_inc;
-                //learntsize_adjust_cnt    = (int)learntsize_adjust_confl;
-                //max_learnts             *= learntsize_inc;
-
-                if (verbosity >= 1)/*auto*/{
-                    printf("c | %9d | %7d %8d %8d | %8d %8d %6.0f | %6.3f %% | %d %d | %d %.1f (%.1f) %.1f (%.1f) %d (%d-%d) %d %.2f\n", 
-                           (int)conflicts, 
-                           (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]), nClauses(), (int)clauses_literals, 
-                           (int)lF.size()/*max_learnts*/, nLearnts(), (double)learnts_literals/(lF.size()+nLearnts()), progressEstimate()*100,
-                           starts, conflicts / starts,
-                           luby_restart, K, (double)opt_K, R, (double)opt_R, LBD_cut, (int32_t)opt_lbd_cut, (int32_t)opt_lbd_cut_max,
-                           (int32_t)opt_cp_increase, (double)opt_core_tolerance);
-}/*auto*/
-            }
+            
 
         }else{
             // NO CONFLICT
@@ -994,7 +975,7 @@
         map.growTo(x+1, -1);
         map[x] = max++;
     }
-    return map[x];
+    
 }
 
 
@@ -1028,7 +1009,8 @@
     // Handle case when solver is in contradictory state:
     if (!ok){
         fprintf(f, "p cnf 1 2\n1 0\n-1 0\n");
-        return; }
+        return;
+        static IntOption     opt_phase_saving      (_cat, "phase-saving", "Controls the level of phase saving (0=none, 1=limited, 2=full)", 2, IntRange(0, 2)); }
 
     vec<Var> map; Var max = 0;
 
@@ -1066,9 +1048,7 @@
         toDimacs(f, ca[clauses[i]], map, max);
 }/*auto*/
 
-    if (verbosity > 0)/*auto*/{
-        printf("Wrote %d clauses with %d variables.\n", cnt, max);
-}/*auto*/
+    
 }
 
 
