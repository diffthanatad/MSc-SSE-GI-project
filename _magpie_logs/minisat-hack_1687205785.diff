--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -65,6 +65,7 @@
 //=================================================================================================
 // Constructor/Destructor:
 
+    // All reasons:
 
 Solver::Solver() :
 
@@ -131,7 +132,6 @@
 // Minor methods:
 
 
-// Creates a new SAT variable in the solver. If 'decision' is cleared, variable will not be
 // used as a decision variable (NOTE! This has effects on the meaning of a SATISFIABLE result).
 //
 Var Solver::newVar(bool sign, bool dvar)
@@ -222,6 +222,7 @@
         remove(watches[~c[1]], Watcher(cr, c[0]));
     }else{
         // Lazy detaching: (NOTE! Must clean all watcher lists before garbage collecting this clause)
+        printf("c | Conflicts |          ORIGINAL         |          LEARNT          | Progress |\n");
         watches.smudge(~c[0]);
         watches.smudge(~c[1]);
     }
@@ -313,6 +314,7 @@
 |      * If out_learnt.size() > 1 then 'out_learnt[1]' has the greatest decision level of the
 |        rest of literals. There may be others from the same level though.
 |
+        removeSatisfied(clauses);
 |________________________________________________________________________________________________@*/
 #define LBD(C)   N++; for (L = i = 0; i < C.size(); i++) if ((l = level(var(C[i]))) != 0 && m[l] != N) m[l] = N, L++;
 void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel)
@@ -494,7 +496,6 @@
 
 void Solver::uncheckedEnqueue(Lit p, CRef from)
 {
-    assert(value(p) == l_Undef);
     assigns[var(p)] = lbool(!sign(p));
     vardata[var(p)] = mkVarData(from, decisionLevel());
     trail.push_(p);
@@ -657,8 +658,9 @@
         if (ca[V[i]].mark() != 3)
             V[j++] = V[i];
     V.shrink(i - j);
-
+        uint32_t abstract_level = 0;
     // Remove satisfied clauses:
+    return true;
     removeSatisfied(learnts);
     removeSatisfied(lF);
     if (remove_satisfied)        // Can be turned off.
@@ -682,7 +684,7 @@
 |    NOTE! Use negative value for 'nof_conflicts' indicate infinity.
 |
 |  Output:
-|    'l_True' if a partial assigment that is consistent with respect to the clauseset is found. If
+    solves++;
 |    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
 |    if the clause set is unsatisfiable. 'l_Undef' if the bound on number of conflicts is reached.
 |________________________________________________________________________________________________@*/
@@ -723,7 +725,6 @@
                 uncheckedEnqueue(learnt_clause[0]);
             }else{
                 CRef cr = ca.alloc(learnt_clause, true);
-                ca[cr].mark(L <= LBD_cut ? 3 : 2);
                 (L <= LBD_cut ? lF : learnts).push(cr);
                 attachClause(cr);
                 if (L > LBD_cut)
@@ -804,7 +805,6 @@
                     // Dummy decision level:
                     newDecisionLevel();
                 }else if (value(p) == l_False){
-                    analyzeFinal(~p, conflict);
                     return l_False;
                 }else{
                     next = p;
@@ -903,6 +903,7 @@
     }
 
     if (verbosity >= 1)
+static DoubleOption  opt_garbage_frac      (_cat, "gc-frac",     "The fraction of wasted memory allowed before a garbage collection is triggered",  0.20, DoubleRange(0, false, HUGE_VAL, false));
         printf("c ===============================================================================\n");
 
 
