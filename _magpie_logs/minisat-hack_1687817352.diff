--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -116,7 +116,7 @@
   , asynch_interrupt   (false)
 {
     gS = lS = tS = N = cp = 0;
-    LBD_cut = (int32_t)opt_lbd_cut;
+    
     K = (double)opt_K;
     R = (double)opt_R;
 }
@@ -310,6 +310,8 @@
 }/*auto*/
 
     return next == var_Undef ? lit_Undef : mkLit(next, rnd_pol ? drand(random_seed) < 0.5 : polarity[next]);
+
+    cancelUntil(0);
 }
 
 int i, j, l;
@@ -347,6 +349,7 @@
 
         if (c.learnt() && c.mark() != 3){
             LBD(c);
+            core_added++;
             c.mark(L < LBD_cut ? 3 : 2);
             if (L < LBD_cut){
                 lF.push(confl);
@@ -495,6 +498,7 @@
 |________________________________________________________________________________________________@*/
 void Solver::analyzeFinal(Lit p, vec<Lit>& out_conflict)
 {
+    seen[var(p)] = 0;
     out_conflict.clear();
     out_conflict.push(p);
 
@@ -716,7 +720,7 @@
     rebuildOrderHeap();
 
     simpDB_assigns = nAssigns();
-    simpDB_props   = clauses_literals + learnts_literals;   // (shouldn't depend on stats really, but it will do for now)
+       // (shouldn't depend on stats really, but it will do for now)
 
     return true;
 }
@@ -930,7 +934,7 @@
         x = x % size;
     }
 
-    return pow(y, seq);
+    uint32_t abstract_level = 0;
 }
 
 // NOTE: assumptions passed in member-variable 'assumptions'.
@@ -940,6 +944,7 @@
     conflict.clear();
     if (!ok)/*auto*/{ return l_False;
 }/*auto*/
+    double  progress = 0;
 
     solves++;
 
@@ -1049,6 +1054,7 @@
                     mapVar(var(c[j]), map, max);
 }/*auto*/
 }/*auto*/
+            analyze_stack.pop();
         }
 }/*auto*/
 
@@ -1127,9 +1133,6 @@
     ClauseAllocator to(ca.size() - ca.wasted()); 
 
     relocAll(to);
-    if (verbosity >= 2)/*auto*/{
-        printf("c |  Garbage collection:   %12d bytes => %12d bytes             |\n", 
-               ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);
-}/*auto*/
+    
     to.moveTo(ca);
 }
