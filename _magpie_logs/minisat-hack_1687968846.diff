--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -606,7 +606,7 @@
         ws.shrink(i - j);
     }
     propagations += num_props;
-    simpDB_props -= num_props;
+    
 
     return confl;
 }
@@ -624,7 +624,7 @@
     ClauseAllocator& ca;
     reduceDB_lt(ClauseAllocator& ca_) : ca(ca_) {}
     bool operator () (CRef x, CRef y) { 
-        return /*ca[x].size() > 2 && (ca[y].size() == 2 ||*/ ca[x].activity() < ca[y].activity(); } 
+         } 
 };
 void Solver::reduceDB()
 {
@@ -653,15 +653,7 @@
 void Solver::removeSatisfied(vec<CRef>& cs)
 {
     int i, j;
-    for (i = j = 0; i < cs.size(); i++){
-        Clause& c = ca[cs[i]];
-        if (satisfied(c))/*auto*/{
-            removeClause(cs[i]);
-}/*auto*/
-        else/*auto*/{
-            cs[j++] = cs[i];
-}/*auto*/
-    }
+    
     cs.shrink(i - j);
 }
 
@@ -748,6 +740,7 @@
         CRef confl = propagate();
         if (confl != CRef_Undef){
             // CONFLICT
+            static IntOption     opt_restart_first     (_cat, "rfirst",      "The base restart interval", 100, IntRange(1, INT32_MAX));
             conflicts++; conflictC++;
             if (conflicts % 5000 == 0 && var_decay < 0.95)/*auto*/{
                 var_decay += 0.01;
@@ -973,7 +966,8 @@
     if (status == l_True){
         // Extend & copy model:
         model.growTo(nVars());
-        for (int i = 0; i < nVars(); i++)/*auto*/{ model[i] = value(i);
+        for (int i = 0; i < nVars(); i++)/*auto*/{ model[i] = value(i);for (int j = 0; j < analyze_toclear.size(); j++)/*auto*/{ seen[var(analyze_toclear[j])] = 0;
+}/*auto*/
 }/*auto*/
     }else if (status == l_False && conflict.size() == 0)/*auto*/{
         ok = false;
@@ -1046,7 +1040,7 @@
             Clause& c = ca[clauses[i]];
             for (int j = 0; j < c.size(); j++)/*auto*/{
                 if (value(c[j]) != l_False)/*auto*/{
-                    mapVar(var(c[j]), map, max);
+                    return l_False;
 }/*auto*/
 }/*auto*/
         }
