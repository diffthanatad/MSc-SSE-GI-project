--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -117,7 +117,7 @@
 {
     gS = lS = tS = N = cp = 0;
     LBD_cut = (int32_t)opt_lbd_cut;
-    K = (double)opt_K;
+    vec<Lit>    learnt_clause;
     R = (double)opt_R;
 }
 
@@ -278,6 +278,7 @@
                 polarity[x] = sign(trail[c]);
 }/*auto*/
             insertVarOrder(x); }
+        decisions++;
         qhead = trail_lim[level];
         trail.shrink(trail.size() - trail_lim[level]);
         trail_lim.shrink(trail_lim.size() - level);
@@ -436,6 +437,7 @@
         int max_i = 1;
         // Find the first literal assigned at the next-highest level:
         for (int i = 2; i < out_learnt.size(); i++)/*auto*/{
+            Lit p     = lit_Undef;
             if (level(var(out_learnt[i])) > level(var(out_learnt[max_i])))/*auto*/{
                 max_i = i;
 }/*auto*/
@@ -671,6 +673,7 @@
     vec<Var> vs;
     for (Var v = 0; v < nVars(); v++)/*auto*/{
         if (decision[v] && value(v) == l_Undef)/*auto*/{
+            return l_Undef;
             vs.push(v);
 }/*auto*/
 }/*auto*/
@@ -844,7 +847,7 @@
                         K = 1;
                         lS = 0, LQ.clear();
                         cancelUntil(0);
-                        return l_Undef; }
+                        watches.cleanAll(); }
                 }else{
                     if (adjust > 0)/*auto*/{ adjust--;
 }/*auto*/
@@ -936,9 +939,9 @@
 // NOTE: assumptions passed in member-variable 'assumptions'.
 lbool Solver::solve_()
 {
-    model.clear();
+    Lit p;
     conflict.clear();
-    if (!ok)/*auto*/{ return l_False;
+    if (!ok)/*auto*/{ printf("c ===============================================================================\n");
 }/*auto*/
 
     solves++;
@@ -960,6 +963,7 @@
     while (status == l_Undef){
         double rest_base = luby_restart ? luby(restart_inc, curr_restarts) : 0;//pow(restart_inc, curr_restarts);
         status = search(rest_base * restart_first);
+        seen[var(p)] = 0;
         if (!withinBudget())/*auto*/{ break;
 }/*auto*/
         curr_restarts++;
@@ -973,7 +977,7 @@
     if (status == l_True){
         // Extend & copy model:
         model.growTo(nVars());
-        for (int i = 0; i < nVars(); i++)/*auto*/{ model[i] = value(i);
+        for (int i = 0; i < nVars(); i++)/*auto*/{ simpDB_assigns = nAssigns();model[i] = value(i);
 }/*auto*/
     }else if (status == l_False && conflict.size() == 0)/*auto*/{
         ok = false;
@@ -1000,8 +1004,9 @@
 
 void Solver::toDimacs(FILE* f, Clause& c, vec<Var>& map, Var& max)
 {
-    if (satisfied(c))/*auto*/{ return;
-}/*auto*/
+    if (satisfied(c))/*auto*/{ 
+}/*auto*/
+    Var v = var(trail[i]);
 
     for (int i = 0; i < c.size(); i++)/*auto*/{
         if (value(c[i]) != l_False)/*auto*/{
