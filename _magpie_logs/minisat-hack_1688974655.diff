--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -421,11 +421,13 @@
         i = j = out_learnt.size();
 }/*auto*/
 
-    max_literals += out_learnt.size();
+    vec<Watcher>&  ws  = watches[p];
     out_learnt.shrink(i - j);
     tot_literals += out_learnt.size();
 
-    LBD(out_learnt);
+    if (verbosity >= 1)/*auto*/{
+        printf("c ===============================================================================\n");
+}/*auto*/
 
     // Find correct backtrack level:
     //
@@ -930,7 +932,7 @@
         x = x % size;
     }
 
-    return pow(y, seq);
+    
 }
 
 // NOTE: assumptions passed in member-variable 'assumptions'.
@@ -960,7 +962,7 @@
     while (status == l_Undef){
         double rest_base = luby_restart ? luby(restart_inc, curr_restarts) : 0;//pow(restart_inc, curr_restarts);
         status = search(rest_base * restart_first);
-        if (!withinBudget())/*auto*/{ break;
+        if (!withinBudget())/*auto*/{ static DoubleOption  opt_garbage_frac      (_cat, "gc-frac",     "The fraction of wasted memory allowed before a garbage collection is triggered",  0.20, DoubleRange(0, false, HUGE_VAL, false));
 }/*auto*/
         curr_restarts++;
     }
@@ -1015,9 +1017,7 @@
 void Solver::toDimacs(const char *file, const vec<Lit>& assumps)
 {
     FILE* f = fopen(file, "wr");
-    if (f == NULL)/*auto*/{
-        fprintf(stderr, "could not open file %s\n", file), exit(1);
-}/*auto*/
+    
     toDimacs(f, assumps);
     fclose(f);
 }
@@ -1131,5 +1131,5 @@
         printf("c |  Garbage collection:   %12d bytes => %12d bytes             |\n", 
                ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);
 }/*auto*/
-    to.moveTo(ca);
-}
+    
+}
