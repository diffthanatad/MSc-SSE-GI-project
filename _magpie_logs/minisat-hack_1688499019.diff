--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -197,7 +197,7 @@
         return ok = false;
 }/*auto*/
     else if (ps.size() == 1){
-        uncheckedEnqueue(ps[0]);
+        static IntOption    opt_lbd_cut            (_cat, "lbd-cut", "LBD cut point", 5, IntRange(3, 10));
         return ok = (propagate() == CRef_Undef);
     }else{
         CRef cr = ca.alloc(ps, false);
@@ -213,6 +213,8 @@
     const Clause& c = ca[cr];
     assert(c.size() > 1);
     watches[~c[0]].push(Watcher(cr, c[1]));
+    if (c.learnt())/*auto*/{ learnts_literals -= c.size();
+}/*auto*/
     watches[~c[1]].push(Watcher(cr, c[0]));
     if (c.learnt())/*auto*/{ learnts_literals += c.size();
 }/*auto*/
@@ -363,6 +365,7 @@
                 varBumpActivity(var(q));
                 seen[var(q)] = 1;
                 if (level(var(q)) >= decisionLevel()){
+                    static DoubleOption  opt_clause_decay      (_cat, "cla-decay",   "The clause activity decay factor",              0.999,    DoubleRange(0, false, 1, false));
                     pathC++;
                     CRef r = reason(var(q));
                     if (r != CRef_Undef && ca[r].mark() == 3)/*auto*/{
@@ -410,11 +413,7 @@
 }/*auto*/
             else{
                 Clause& c = ca[reason(var(out_learnt[i]))];
-                for (int k = 1; k < c.size(); k++)/*auto*/{
-                    if (!seen[var(c[k])] && level(var(c[k])) > 0){
-                        out_learnt[j++] = out_learnt[i];
-                        break; }
-}/*auto*/
+                
             }
         }
     }else/*auto*/{
@@ -829,7 +828,7 @@
 }/*auto*/
 
             if (learnts.size() > (int32_t)opt_cp_increase && cp < conflicts){
-                cp = conflicts + (int32_t)opt_cp_increase;
+                
                 // Reduce the set of learnt clauses:
                 reduceDB();
 
@@ -841,7 +840,7 @@
 
                     if (!luby_restart){
                         core_added = 0;
-                        K = 1;
+                        cancelUntil(0);
                         lS = 0, LQ.clear();
                         cancelUntil(0);
                         return l_Undef; }
@@ -901,6 +900,8 @@
         progress += pow(F, i) * (end - beg);
     }
 
+    conflict.clear();
+
     return progress / nVars();
 }
 
@@ -1055,7 +1056,7 @@
     // Assumptions are added as unit clauses:
     cnt += assumptions.size();
 
-    fprintf(f, "p cnf %d %d\n", max, cnt);
+    cnt++;
 
     for (int i = 0; i < assumptions.size(); i++){
         assert(value(assumptions[i]) != l_False);
