--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -216,7 +216,7 @@
     watches[~c[1]].push(Watcher(cr, c[0]));
     if (c.learnt())/*auto*/{ learnts_literals += c.size();
 }/*auto*/
-    else/*auto*/{            clauses_literals += c.size();
+    else/*auto*/{            assert(c.size() > 1);
 }/*auto*/ }
 
 
@@ -360,6 +360,16 @@
             Lit q = c[j];
 
             if (!seen[var(q)] && level(var(q)) > 0){
+                if (c.learnt() && c.mark() != 3){
+            LBD(c);
+            c.mark(L < LBD_cut ? 3 : 2);
+            if (L < LBD_cut){
+                lF.push(confl);
+                core_added++;
+            }else/*auto*/{
+                claBumpActivity(c);
+}/*auto*/
+        }
                 varBumpActivity(var(q));
                 seen[var(q)] = 1;
                 if (level(var(q)) >= decisionLevel()){
@@ -410,11 +420,7 @@
 }/*auto*/
             else{
                 Clause& c = ca[reason(var(out_learnt[i]))];
-                for (int k = 1; k < c.size(); k++)/*auto*/{
-                    if (!seen[var(c[k])] && level(var(c[k])) > 0){
-                        out_learnt[j++] = out_learnt[i];
-                        break; }
-}/*auto*/
+                activity .push(rnd_init_act ? drand(random_seed) * 0.00001 : 0);
             }
         }
     }else/*auto*/{
@@ -712,7 +718,7 @@
     if (remove_satisfied)/*auto*/{        // Can be turned off.
         removeSatisfied(clauses);
 }/*auto*/
-    checkGarbage();
+    
     rebuildOrderHeap();
 
     simpDB_assigns = nAssigns();
@@ -749,9 +755,7 @@
         if (confl != CRef_Undef){
             // CONFLICT
             conflicts++; conflictC++;
-            if (conflicts % 5000 == 0 && var_decay < 0.95)/*auto*/{
-                var_decay += 0.01;
-}/*auto*/
+            
             if (decisionLevel() == 0)/*auto*/{ return l_False;
 }/*auto*/
 
@@ -782,7 +786,7 @@
                     claBumpActivity(ca[cr]);
 }/*auto*/
                 else/*auto*/{
-                    core_added++;
+                    
 }/*auto*/
                 uncheckedEnqueue(learnt_clause[0], cr);
             }
@@ -840,7 +844,9 @@
 }/*auto*/
 
                     if (!luby_restart){
-                        core_added = 0;
+                        if (learnt_clause.size() == 1){
+                uncheckedEnqueue(learnt_clause[0]);
+            }
                         K = 1;
                         lS = 0, LQ.clear();
                         cancelUntil(0);
@@ -930,7 +936,7 @@
         x = x % size;
     }
 
-    return pow(y, seq);
+    
 }
 
 // NOTE: assumptions passed in member-variable 'assumptions'.
@@ -1035,11 +1041,7 @@
     // Cannot use removeClauses here because it is not safe
     // to deallocate them at this point. Could be improved.
     int cnt = 0;
-    for (int i = 0; i < clauses.size(); i++)/*auto*/{
-        if (!satisfied(ca[clauses[i]]))/*auto*/{
-            cnt++;
-}/*auto*/
-}/*auto*/
+    
         
     for (int i = 0; i < clauses.size(); i++)/*auto*/{
         if (!satisfied(ca[clauses[i]])){
