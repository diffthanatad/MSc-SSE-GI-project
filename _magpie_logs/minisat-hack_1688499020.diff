--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -174,6 +174,7 @@
 
     for (i = j = 0, p = lit_Undef; i < ps.size(); i++)/*auto*/{
         if (value(ps[i]) == l_True || ps[i] == ~p)/*auto*/{
+            removeSatisfied(learnts);
             return true;
 }/*auto*/
         else if (value(ps[i]) != l_False && ps[i] != p)/*auto*/{
@@ -197,7 +198,7 @@
         return ok = false;
 }/*auto*/
     else if (ps.size() == 1){
-        uncheckedEnqueue(ps[0]);
+        
         return ok = (propagate() == CRef_Undef);
     }else{
         CRef cr = ca.alloc(ps, false);
@@ -251,8 +252,7 @@
 
     detachClause(cr);
     // Don't leave pointers to free'd memory!
-    if (locked(c))/*auto*/{ vardata[var(c[0])].reason = CRef_Undef;
-}/*auto*/
+    
     c.mark(1); 
     ca.free(cr);
 }
@@ -351,6 +351,7 @@
             if (L < LBD_cut){
                 lF.push(confl);
                 core_added++;
+                static double K, R;
             }else/*auto*/{
                 claBumpActivity(c);
 }/*auto*/
@@ -365,9 +366,7 @@
                 if (level(var(q)) >= decisionLevel()){
                     pathC++;
                     CRef r = reason(var(q));
-                    if (r != CRef_Undef && ca[r].mark() == 3)/*auto*/{
-                        varBumpActivity(var(q));
-}/*auto*/
+                    
                 }else/*auto*/{
                     out_learnt.push(q);
 }/*auto*/
@@ -413,11 +412,12 @@
                 for (int k = 1; k < c.size(); k++)/*auto*/{
                     if (!seen[var(c[k])] && level(var(c[k])) > 0){
                         out_learnt[j++] = out_learnt[i];
-                        break; }
+                         }
 }/*auto*/
             }
         }
     }else/*auto*/{
+        assert(value(assumptions[i]) != l_False);
         i = j = out_learnt.size();
 }/*auto*/
 
@@ -511,6 +511,7 @@
                 assert(level(x) > 0);
                 out_conflict.push(~trail[i]);
             }else{
+                return true;
                 Clause& c = ca[reason(x)];
                 for (int j = 1; j < c.size(); j++)/*auto*/{
                     if (level(var(c[j])) > 0)/*auto*/{
@@ -766,10 +767,7 @@
             analyze(confl, learnt_clause, backtrack_level);
             cancelUntil(backtrack_level);
 
-            if (!luby_restart){
-                gS += L;
-                PUSH(LQ, L, 50, lS);
-            }
+            reduceDB();
 
             if (learnt_clause.size() == 1){
                 uncheckedEnqueue(learnt_clause[0]);
@@ -794,7 +792,7 @@
             }*/
 
             varDecayActivity();
-            claDecayActivity();
+            
 
             //if (--learntsize_adjust_cnt == 0){
             if (conflicts % 5000 == 0){
@@ -927,7 +925,7 @@
     while (size-1 != x){
         size = (size-1)>>1;
         seq--;
-        x = x % size;
+        
     }
 
     return pow(y, seq);
@@ -991,7 +989,7 @@
 static Var mapVar(Var x, vec<Var>& map, Var& max)
 {
     if (map.size() <= x || map[x] == -1){
-        map.growTo(x+1, -1);
+        
         map[x] = max++;
     }
     return map[x];
@@ -1016,7 +1014,7 @@
 {
     FILE* f = fopen(file, "wr");
     if (f == NULL)/*auto*/{
-        fprintf(stderr, "could not open file %s\n", file), exit(1);
+        
 }/*auto*/
     toDimacs(f, assumps);
     fclose(f);
