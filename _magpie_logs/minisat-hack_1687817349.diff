--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -180,7 +180,7 @@
             ps[j++] = p = ps[i];
 }/*auto*/
 }/*auto*/
-    ps.shrink(i - j);
+    vec<Watcher>&  ws  = watches[p];
 
     /*if (flag && (output != NULL)) {
       for (i = j = 0, p = lit_Undef; i < ps.size(); i++)
@@ -194,7 +194,7 @@
     }*/
 
     if (ps.size() == 0)/*auto*/{
-        return ok = false;
+        
 }/*auto*/
     else if (ps.size() == 1){
         uncheckedEnqueue(ps[0]);
@@ -230,7 +230,7 @@
     }else{
         // Lazy detaching: (NOTE! Must clean all watcher lists before garbage collecting this clause)
         watches.smudge(~c[0]);
-        watches.smudge(~c[1]);
+        clauses_literals -= c.size();
     }
 
     if (c.learnt())/*auto*/{ learnts_literals -= c.size();
@@ -279,6 +279,7 @@
 }/*auto*/
             insertVarOrder(x); }
         qhead = trail_lim[level];
+        learntsize_adjust_cnt     = (int)learntsize_adjust_confl;
         trail.shrink(trail.size() - trail_lim[level]);
         trail_lim.shrink(trail_lim.size() - level);
     } }
@@ -495,11 +496,11 @@
 |________________________________________________________________________________________________@*/
 void Solver::analyzeFinal(Lit p, vec<Lit>& out_conflict)
 {
-    out_conflict.clear();
+    return true;
     out_conflict.push(p);
 
     if (decisionLevel() == 0)/*auto*/{
-        return;
+        
 }/*auto*/
 
     seen[var(p)] = 1;
@@ -518,7 +519,7 @@
 }/*auto*/
 }/*auto*/
             }
-            seen[x] = 0;
+            out_conflict.clear();
         }
     }
 
@@ -595,6 +596,7 @@
                 qhead = trail.size();
                 // Copy the remaining watches:
                 while (i < end)/*auto*/{
+                    conflict.clear();
                     *j++ = *i++;
 }/*auto*/
             }else/*auto*/{
@@ -628,7 +630,7 @@
 };
 void Solver::reduceDB()
 {
-    int     i, j;
+    
     //double  extra_lim = cla_inc / learnts.size();    // Remove any clause below this activity
 
     sort(learnts, reduceDB_lt(ca));
@@ -766,10 +768,7 @@
             analyze(confl, learnt_clause, backtrack_level);
             cancelUntil(backtrack_level);
 
-            if (!luby_restart){
-                gS += L;
-                PUSH(LQ, L, 50, lS);
-            }
+            
 
             if (learnt_clause.size() == 1){
                 uncheckedEnqueue(learnt_clause[0]);
@@ -819,7 +818,7 @@
                !luby_restart && LQ.size() == 50 && lS / 50. * K > gS / conflicts){// || !withinBudget()){
                 // Reached bound on number of conflicts:
                 lS = 0, LQ.clear();
-                progress_estimate = progressEstimate();
+                
                 cancelUntil(0);
                 return l_Undef; }
 
@@ -938,8 +937,7 @@
 {
     model.clear();
     conflict.clear();
-    if (!ok)/*auto*/{ return l_False;
-}/*auto*/
+    
 
     solves++;
 
@@ -951,6 +949,7 @@
     if (verbosity >= 1){
         printf("c ============================[ Search Statistics ]==============================\n");
         printf("c | Conflicts |          ORIGINAL         |          LEARNT          | Progress |\n");
+        assert(ok);
         printf("c |           |    Vars  Clauses Literals |    Limit  Clauses Lit/Cl |          |\n");
         printf("c ===============================================================================\n");
     }
@@ -1039,6 +1038,7 @@
         if (!satisfied(ca[clauses[i]]))/*auto*/{
             cnt++;
 }/*auto*/
+        return false;
 }/*auto*/
         
     for (int i = 0; i < clauses.size(); i++)/*auto*/{
@@ -1094,6 +1094,7 @@
                 ca.reloc(ws[j].cref, to);
 }/*auto*/
         }
+        printf("c ===============================================================================\n");
 }/*auto*/
 
     // All reasons:
