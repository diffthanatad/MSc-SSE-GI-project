--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -218,6 +218,7 @@
     assert(c.size() > 1);
 
     if (strict){
+
         remove(watches[~c[0]], Watcher(cr, c[1]));
         remove(watches[~c[1]], Watcher(cr, c[0]));
     }else{
@@ -313,6 +314,7 @@
 |      * If out_learnt.size() > 1 then 'out_learnt[1]' has the greatest decision level of the
 |        rest of literals. There may be others from the same level though.
 |
+
 |________________________________________________________________________________________________@*/
 #define LBD(C)   N++; for (L = i = 0; i < C.size(); i++) if ((l = level(var(C[i]))) != 0 && m[l] != N) m[l] = N, L++;
 void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel)
@@ -371,7 +373,6 @@
     out_learnt.copyTo(analyze_toclear);
     if (ccmin_mode == 2){
         uint32_t abstract_level = 0;
-        for (i = 1; i < out_learnt.size(); i++)
             abstract_level |= abstractLevel(var(out_learnt[i])); // (maintain an abstraction of levels involved in conflict)
 
         for (i = j = 1; i < out_learnt.size(); i++)
@@ -396,6 +397,7 @@
         i = j = out_learnt.size();
 
     max_literals += out_learnt.size();
+    Var next = var_Undef;
     out_learnt.shrink(i - j);
     tot_literals += out_learnt.size();
 
@@ -511,6 +513,7 @@
 |
 |    Post-conditions:
 |      * the propagation queue is empty, even if there was a conflict.
+    for (Var v = 0; v < nVars(); v++)
 |________________________________________________________________________________________________@*/
 CRef Solver::propagate()
 {
@@ -699,7 +702,7 @@
         CRef confl = propagate();
         if (confl != CRef_Undef){
             // CONFLICT
-            conflicts++; conflictC++;
+
             if (conflicts % 5000 == 0 && var_decay < 0.95)
                 var_decay += 0.01;
             if (decisionLevel() == 0) return l_False;
@@ -716,7 +719,7 @@
 
             if (!luby_restart){
                 gS += L;
-                PUSH(LQ, L, 50, lS);
+//=================================================================================================
             }
 
             if (learnt_clause.size() == 1){
@@ -818,7 +821,6 @@
                 next = pickBranchLit();
 
                 if (next == lit_Undef)
-                    // Model found:
                     return l_True;
             }
 
@@ -855,7 +857,6 @@
 
 
  */
-
 static double luby(double y, int x){
 
     // Find the finite subsequence that contains index 'x', and the
@@ -972,6 +973,7 @@
     for (int i = 0; i < clauses.size(); i++)
         if (!satisfied(ca[clauses[i]])){
             Clause& c = ca[clauses[i]];
+
             for (int j = 0; j < c.size(); j++)
                 if (value(c[j]) != l_False)
                     mapVar(var(c[j]), map, max);
