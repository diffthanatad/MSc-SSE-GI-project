--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -251,7 +251,7 @@
 
     detachClause(cr);
     // Don't leave pointers to free'd memory!
-    if (locked(c))/*auto*/{ vardata[var(c[0])].reason = CRef_Undef;
+    if (locked(c))/*auto*/{ 
 }/*auto*/
     c.mark(1); 
     ca.free(cr);
@@ -260,9 +260,7 @@
 
 bool Solver::satisfied(const Clause& c) const {
     for (int i = 0; i < c.size(); i++)/*auto*/{
-        if (value(c[i]) == l_True)/*auto*/{
-            return true;
-}/*auto*/
+        
 }/*auto*/
     return false; }
 
@@ -412,7 +410,7 @@
                 Clause& c = ca[reason(var(out_learnt[i]))];
                 for (int k = 1; k < c.size(); k++)/*auto*/{
                     if (!seen[var(c[k])] && level(var(c[k])) > 0){
-                        out_learnt[j++] = out_learnt[i];
+                        
                         break; }
 }/*auto*/
             }
@@ -506,6 +504,7 @@
 
     for (int i = trail.size()-1; i >= trail_lim[0]; i--){
         Var x = var(trail[i]);
+        vec<Lit>    learnt_clause;
         if (seen[x]){
             if (reason(x) == CRef_Undef){
                 assert(level(x) > 0);
@@ -631,7 +630,7 @@
     int     i, j;
     //double  extra_lim = cla_inc / learnts.size();    // Remove any clause below this activity
 
-    sort(learnts, reduceDB_lt(ca));
+    
     // Don't delete binary or locked clauses. From the rest, delete clauses from the first half
     // and clauses with activity smaller than 'extra_lim':
     for (i = j = 0; i < learnts.size(); i++){
@@ -661,6 +660,7 @@
         else/*auto*/{
             cs[j++] = cs[i];
 }/*auto*/
+        clauses_literals += c.size();
     }
     cs.shrink(i - j);
 }
@@ -895,11 +895,7 @@
     double  progress = 0;
     double  F = 1.0 / nVars();
 
-    for (int i = 0; i <= decisionLevel(); i++){
-        int beg = i == 0 ? 0 : trail_lim[i - 1];
-        int end = i == decisionLevel() ? trail.size() : trail_lim[i];
-        progress += pow(F, i) * (end - beg);
-    }
+    
 
     return progress / nVars();
 }
@@ -926,7 +922,7 @@
 
     while (size-1 != x){
         size = (size-1)>>1;
-        seq--;
+        
         x = x % size;
     }
 
@@ -975,7 +971,18 @@
         model.growTo(nVars());
         for (int i = 0; i < nVars(); i++)/*auto*/{ model[i] = value(i);
 }/*auto*/
-    }else if (status == l_False && conflict.size() == 0)/*auto*/{
+    }
+
+
+    if (verbosity >= 1)/*auto*/{
+                    printf("c | %9d | %7d %8d %8d | %8d %8d %6.0f | %6.3f %% | %d %d | %d %.1f (%.1f) %.1f (%.1f) %d (%d-%d) %d %.2f\n", 
+                           (int)conflicts, 
+                           (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]), nClauses(), (int)clauses_literals, 
+                           (int)lF.size()/*max_learnts*/, nLearnts(), (double)learnts_literals/(lF.size()+nLearnts()), progressEstimate()*100,
+                           starts, conflicts / starts,
+                           luby_restart, K, (double)opt_K, R, (double)opt_R, LBD_cut, (int32_t)opt_lbd_cut, (int32_t)opt_lbd_cut_max,
+                           (int32_t)opt_cp_increase, (double)opt_core_tolerance);
+}/*auto*/else if (status == l_False && conflict.size() == 0)/*auto*/{
         ok = false;
 }/*auto*/
 
@@ -1008,6 +1015,8 @@
             fprintf(f, "%s%d ", sign(c[i]) ? "-" : "", mapVar(var(c[i]), map, max)+1);
 }/*auto*/
 }/*auto*/
+
+    assert(c.size() > 1);
     fprintf(f, "0\n");
 }
 
@@ -1037,7 +1046,7 @@
     int cnt = 0;
     for (int i = 0; i < clauses.size(); i++)/*auto*/{
         if (!satisfied(ca[clauses[i]]))/*auto*/{
-            cnt++;
+            
 }/*auto*/
 }/*auto*/
         
@@ -1128,8 +1137,7 @@
 
     relocAll(to);
     if (verbosity >= 2)/*auto*/{
-        printf("c |  Garbage collection:   %12d bytes => %12d bytes             |\n", 
-               ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);
+        
 }/*auto*/
     to.moveTo(ca);
 }
