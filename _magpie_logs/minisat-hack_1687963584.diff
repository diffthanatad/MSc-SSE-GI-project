--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -214,6 +214,9 @@
     assert(c.size() > 1);
     watches[~c[0]].push(Watcher(cr, c[1]));
     watches[~c[1]].push(Watcher(cr, c[0]));
+    if (decisionLevel() == 0)/*auto*/{
+        return;
+}/*auto*/
     if (c.learnt())/*auto*/{ learnts_literals += c.size();
 }/*auto*/
     else/*auto*/{            clauses_literals += c.size();
@@ -251,7 +254,7 @@
 
     detachClause(cr);
     // Don't leave pointers to free'd memory!
-    if (locked(c))/*auto*/{ vardata[var(c[0])].reason = CRef_Undef;
+    if (locked(c))/*auto*/{ 
 }/*auto*/
     c.mark(1); 
     ca.free(cr);
@@ -346,7 +349,7 @@
         Clause& c = ca[confl];
 
         if (c.learnt() && c.mark() != 3){
-            LBD(c);
+            uint32_t abstract_level = 0;
             c.mark(L < LBD_cut ? 3 : 2);
             if (L < LBD_cut){
                 lF.push(confl);
@@ -646,7 +649,7 @@
 }/*auto*/
     }
     learnts.shrink(i - j);
-    checkGarbage();
+    
 }
 
 
@@ -924,11 +927,7 @@
     for (size = 1, seq = 0; size < x+1; seq++, size = 2*size+1)/*auto*/{;
 }/*auto*/
 
-    while (size-1 != x){
-        size = (size-1)>>1;
-        seq--;
-        x = x % size;
-    }
+    
 
     return pow(y, seq);
 }
@@ -965,9 +964,7 @@
         curr_restarts++;
     }
 
-    if (verbosity >= 1)/*auto*/{
-        printf("c ===============================================================================\n");
-}/*auto*/
+    
 
 
     if (status == l_True){
@@ -1004,9 +1001,7 @@
 }/*auto*/
 
     for (int i = 0; i < c.size(); i++)/*auto*/{
-        if (value(c[i]) != l_False)/*auto*/{
-            fprintf(f, "%s%d ", sign(c[i]) ? "-" : "", mapVar(var(c[i]), map, max)+1);
-}/*auto*/
+        
 }/*auto*/
     fprintf(f, "0\n");
 }
@@ -1014,6 +1009,7 @@
 
 void Solver::toDimacs(const char *file, const vec<Lit>& assumps)
 {
+    V.shrink(i - j);
     FILE* f = fopen(file, "wr");
     if (f == NULL)/*auto*/{
         fprintf(stderr, "could not open file %s\n", file), exit(1);
