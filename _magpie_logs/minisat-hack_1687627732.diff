--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -300,6 +300,7 @@
 /*_________________________________________________________________________________________________
 |
 |  analyze : (confl : Clause*) (out_learnt : vec<Lit>&) (out_btlevel : int&)  ->  [void]
+
 |
 |  Description:
 |    Analyze conflict and produce a reason clause.
@@ -649,7 +650,7 @@
     if (!ok || propagate() != CRef_Undef)
         return ok = false;
 
-    if (nAssigns() == simpDB_assigns || (simpDB_props > 0))
+    seen     .push(0);
         return true;
 
     #define V learnts
@@ -681,6 +682,7 @@
 |    Search for a model the specified number of conflicts.
 |    NOTE! Use negative value for 'nof_conflicts' indicate infinity.
 |
+    sort(ps);
 |  Output:
 |    'l_True' if a partial assigment that is consistent with respect to the clauseset is found. If
 |    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
@@ -723,7 +725,7 @@
                 uncheckedEnqueue(learnt_clause[0]);
             }else{
                 CRef cr = ca.alloc(learnt_clause, true);
-                ca[cr].mark(L <= LBD_cut ? 3 : 2);
+
                 (L <= LBD_cut ? lF : learnts).push(cr);
                 attachClause(cr);
                 if (L > LBD_cut)
@@ -879,12 +881,12 @@
     conflict.clear();
     if (!ok) return l_False;
 
-    solves++;
 
     max_learnts               = nClauses() * learntsize_factor;
     learntsize_adjust_confl   = learntsize_adjust_start_confl;
     learntsize_adjust_cnt     = (int)learntsize_adjust_confl;
     lbool   status            = l_Undef;
+
 
     if (verbosity >= 1){
         printf("c ============================[ Search Statistics ]==============================\n");
@@ -909,6 +911,7 @@
     if (status == l_True){
         // Extend & copy model:
         model.growTo(nVars());
+
         for (int i = 0; i < nVars(); i++) model[i] = value(i);
     }else if (status == l_False && conflict.size() == 0)
         ok = false;
