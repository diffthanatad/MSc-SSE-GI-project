--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -345,16 +345,7 @@
         assert(confl != CRef_Undef); // (otherwise should be UIP)
         Clause& c = ca[confl];
 
-        if (c.learnt() && c.mark() != 3){
-            LBD(c);
-            c.mark(L < LBD_cut ? 3 : 2);
-            if (L < LBD_cut){
-                lF.push(confl);
-                core_added++;
-            }else/*auto*/{
-                claBumpActivity(c);
-}/*auto*/
-        }
+        
 
         for (int j = (p == lit_Undef) ? 0 : 1; j < c.size(); j++){
             Lit q = c[j];
@@ -421,7 +412,7 @@
         i = j = out_learnt.size();
 }/*auto*/
 
-    max_literals += out_learnt.size();
+    
     out_learnt.shrink(i - j);
     tot_literals += out_learnt.size();
 
@@ -479,6 +470,9 @@
             }
         }
     }
+    if (conflicts % 5000 == 0 && var_decay < 0.95)/*auto*/{
+                var_decay += 0.01;
+}/*auto*/
 
     return true;
 }
@@ -819,7 +813,7 @@
                !luby_restart && LQ.size() == 50 && lS / 50. * K > gS / conflicts){// || !withinBudget()){
                 // Reached bound on number of conflicts:
                 lS = 0, LQ.clear();
-                progress_estimate = progressEstimate();
+                
                 cancelUntil(0);
                 return l_Undef; }
 
