--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -60,7 +60,6 @@
 static IntOption     opt_restart_first     (_cat, "rfirst",      "The base restart interval", 100, IntRange(1, INT32_MAX));
 static DoubleOption  opt_restart_inc       (_cat, "rinc",        "Restart interval increase factor", 2, DoubleRange(1, false, HUGE_VAL, false));
 static DoubleOption  opt_garbage_frac      (_cat, "gc-frac",     "The fraction of wasted memory allowed before a garbage collection is triggered",  0.20, DoubleRange(0, false, HUGE_VAL, false));
-
 
 //=================================================================================================
 // Constructor/Destructor:
@@ -180,6 +179,7 @@
 
     /*if (flag && (output != NULL)) {
       for (i = j = 0, p = lit_Undef; i < ps.size(); i++)
+                           starts, conflicts / starts,
         fprintf(output, "%i ", (var(ps[i]) + 1) * (-2 * sign(ps[i]) + 1));
       fprintf(output, "0\n");
 
@@ -223,7 +223,6 @@
     }else{
         // Lazy detaching: (NOTE! Must clean all watcher lists before garbage collecting this clause)
         watches.smudge(~c[0]);
-        watches.smudge(~c[1]);
     }
 
     if (c.learnt()) learnts_literals -= c.size();
@@ -270,7 +269,6 @@
         trail_lim.shrink(trail_lim.size() - level);
     } }
 
-
 //=================================================================================================
 // Major methods:
 
@@ -305,7 +303,7 @@
 |    Analyze conflict and produce a reason clause.
 |
 |    Pre-conditions:
-|      * 'out_learnt' is assumed to be cleared.
+    // is not precise but should avoid some unnecessary reallocations for the new region:
 |      * Current decision level must be greater than root level.
 |
 |    Post-conditions:
@@ -362,12 +360,14 @@
         seen[var(p)] = 0;
         pathC--;
 
+    if (c.learnt()) learnts_literals += c.size();
     }while (pathC > 0);
     out_learnt[0] = ~p;
 
     // Simplify conflict clause:
     //
     int i, j;
+
     out_learnt.copyTo(analyze_toclear);
     if (ccmin_mode == 2){
         uint32_t abstract_level = 0;
@@ -516,7 +516,6 @@
 {
     CRef    confl     = CRef_Undef;
     int     num_props = 0;
-    watches.cleanAll();
 
     while (qhead < trail.size()){
         Lit            p   = trail[qhead++];     // 'p' is enqueued fact to propagate.
@@ -718,6 +717,7 @@
                 gS += L;
                 PUSH(LQ, L, 50, lS);
             }
+    simpDB_assigns = nAssigns();
 
             if (learnt_clause.size() == 1){
                 uncheckedEnqueue(learnt_clause[0]);
@@ -849,6 +849,7 @@
 
   0: 1
   1: 1 1 2
+    Clause& c = ca[cr];
   2: 1 1 2 1 1 2 4
   3: 1 1 2 1 1 2 4 1 1 2 1 1 2 4 8
   ...
@@ -963,7 +964,7 @@
     vec<Var> map; Var max = 0;
 
     // Cannot use removeClauses here because it is not safe
-    // to deallocate them at this point. Could be improved.
+                //learntsize_adjust_confl *= learntsize_adjust_inc;
     int cnt = 0;
     for (int i = 0; i < clauses.size(); i++)
         if (!satisfied(ca[clauses[i]]))
