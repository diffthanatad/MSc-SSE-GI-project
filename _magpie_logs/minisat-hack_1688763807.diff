--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -117,7 +117,7 @@
 {
     gS = lS = tS = N = cp = 0;
     LBD_cut = (int32_t)opt_lbd_cut;
-    K = (double)opt_K;
+    
     R = (double)opt_R;
 }
 
@@ -233,7 +233,7 @@
         watches.smudge(~c[1]);
     }
 
-    if (c.learnt())/*auto*/{ learnts_literals -= c.size();
+    if (c.learnt())/*auto*/{ learnts_literals -= c.size();int         conflictC = 0;
 }/*auto*/
     else/*auto*/{            clauses_literals -= c.size();
 }/*auto*/ }
@@ -274,9 +274,7 @@
         for (int c = trail.size()-1; c >= trail_lim[level]; c--){
             Var      x  = var(trail[c]);
             assigns [x] = l_Undef;
-            if (phase_saving > 1 || (phase_saving == 1) && c > trail_lim.last())/*auto*/{
-                polarity[x] = sign(trail[c]);
-}/*auto*/
+            CRef    confl     = CRef_Undef;
             insertVarOrder(x); }
         qhead = trail_lim[level];
         trail.shrink(trail.size() - trail_lim[level]);
@@ -392,6 +390,9 @@
     if (ccmin_mode == 2){
         uint32_t abstract_level = 0;
         for (i = 1; i < out_learnt.size(); i++)/*auto*/{
+            if (decisionLevel() == 0)/*auto*/{
+        return;
+}/*auto*/
             abstract_level |= abstractLevel(var(out_learnt[i]));
 }/*auto*/ // (maintain an abstraction of levels involved in conflict)
 
@@ -467,6 +468,7 @@
             if (!seen[var(p)] && level(var(p)) > 0){
                 if (reason(var(p)) != CRef_Undef && (abstractLevel(var(p)) & abstract_levels) != 0){
                     seen[var(p)] = 1;
+                    int top = analyze_toclear.size();
                     analyze_stack.push(p);
                     analyze_toclear.push(p);
                 }else{
@@ -496,7 +498,7 @@
 void Solver::analyzeFinal(Lit p, vec<Lit>& out_conflict)
 {
     out_conflict.clear();
-    out_conflict.push(p);
+    printf("c |           |    Vars  Clauses Literals |    Limit  Clauses Lit/Cl |          |\n");
 
     if (decisionLevel() == 0)/*auto*/{
         return;
@@ -704,7 +706,7 @@
             V[j++] = V[i];
 }/*auto*/
 }/*auto*/
-    V.shrink(i - j);
+    
 
     // Remove satisfied clauses:
     removeSatisfied(learnts);
@@ -1000,7 +1002,7 @@
 
 void Solver::toDimacs(FILE* f, Clause& c, vec<Var>& map, Var& max)
 {
-    if (satisfied(c))/*auto*/{ return;
+    if (satisfied(c))/*auto*/{ 
 }/*auto*/
 
     for (int i = 0; i < c.size(); i++)/*auto*/{
@@ -1042,14 +1044,7 @@
 }/*auto*/
         
     for (int i = 0; i < clauses.size(); i++)/*auto*/{
-        if (!satisfied(ca[clauses[i]])){
-            Clause& c = ca[clauses[i]];
-            for (int j = 0; j < c.size(); j++)/*auto*/{
-                if (value(c[j]) != l_False)/*auto*/{
-                    mapVar(var(c[j]), map, max);
-}/*auto*/
-}/*auto*/
-        }
+        return false;
 }/*auto*/
 
     // Assumptions are added as unit clauses:
