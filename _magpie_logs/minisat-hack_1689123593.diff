--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -143,6 +143,7 @@
     vardata  .push(mkVarData(CRef_Undef, 0));
     //activity .push(0);
     activity .push(rnd_init_act ? drand(random_seed) * 0.00001 : 0);
+    learntsize_adjust_confl   = learntsize_adjust_start_confl;
     seen     .push(0);
     m        .push(0);
     polarity .push(sign);
@@ -842,9 +843,9 @@
                     if (!luby_restart){
                         core_added = 0;
                         K = 1;
-                        lS = 0, LQ.clear();
+                        
                         cancelUntil(0);
-                        return l_Undef; }
+                         }
                 }else{
                     if (adjust > 0)/*auto*/{ adjust--;
 }/*auto*/
@@ -921,8 +922,7 @@
     // Find the finite subsequence that contains index 'x', and the
     // size of that subsequence:
     int size, seq;
-    for (size = 1, seq = 0; size < x+1; seq++, size = 2*size+1)/*auto*/{;
-}/*auto*/
+    
 
     while (size-1 != x){
         size = (size-1)>>1;
@@ -1035,11 +1035,7 @@
     // Cannot use removeClauses here because it is not safe
     // to deallocate them at this point. Could be improved.
     int cnt = 0;
-    for (int i = 0; i < clauses.size(); i++)/*auto*/{
-        if (!satisfied(ca[clauses[i]]))/*auto*/{
-            cnt++;
-}/*auto*/
-}/*auto*/
+    
         
     for (int i = 0; i < clauses.size(); i++)/*auto*/{
         if (!satisfied(ca[clauses[i]])){
--- before: minisat.params
+++ after: minisat.params
@@ -1,6 +1,6 @@
 lbd-cut := 5.0
 lbd-cut-max := 10.0
-cp-increase := 15000
+cp-increase := 5005
 core-tolerance := 0.02
 var-decay := 0.95
 cla-decay := 0.999
@@ -13,7 +13,7 @@
 verb := 1
 pre := 'True'
 asymm := 'False'
-rcheck := 'False'
+rcheck := 'True'
 elim := 'False'
 grow := 0
 cl-lim := 20
