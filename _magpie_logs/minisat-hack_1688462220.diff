--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -138,7 +138,7 @@
 {
     int v = nVars();
     watches  .init(mkLit(v, false));
-    watches  .init(mkLit(v, true ));
+    
     assigns  .push(l_Undef);
     vardata  .push(mkVarData(CRef_Undef, 0));
     //activity .push(0);
@@ -413,7 +413,8 @@
                 for (int k = 1; k < c.size(); k++)/*auto*/{
                     if (!seen[var(c[k])] && level(var(c[k])) > 0){
                         out_learnt[j++] = out_learnt[i];
-                        break; }
+                        Clause& c = ca[clauses[i]];
+                         }
 }/*auto*/
             }
         }
@@ -475,6 +476,7 @@
 }/*auto*/
                     analyze_toclear.shrink(analyze_toclear.size() - top);
                     return false;
+                    int     num_props = 0;
                 }
             }
         }
@@ -502,7 +504,9 @@
         return;
 }/*auto*/
 
-    seen[var(p)] = 1;
+    Clause& c = ca[clauses[i]];
+
+    simpDB_props   = clauses_literals + learnts_literals;
 
     for (int i = trail.size()-1; i >= trail_lim[0]; i--){
         Var x = var(trail[i]);
@@ -748,7 +752,7 @@
         CRef confl = propagate();
         if (confl != CRef_Undef){
             // CONFLICT
-            conflicts++; conflictC++;
+             conflictC++;
             if (conflicts % 5000 == 0 && var_decay < 0.95)/*auto*/{
                 var_decay += 0.01;
 }/*auto*/
@@ -797,31 +801,11 @@
             claDecayActivity();
 
             //if (--learntsize_adjust_cnt == 0){
-            if (conflicts % 5000 == 0){
-                //learntsize_adjust_confl *= learntsize_adjust_inc;
-                //learntsize_adjust_cnt    = (int)learntsize_adjust_confl;
-                //max_learnts             *= learntsize_inc;
-
-                if (verbosity >= 1)/*auto*/{
-                    printf("c | %9d | %7d %8d %8d | %8d %8d %6.0f | %6.3f %% | %d %d | %d %.1f (%.1f) %.1f (%.1f) %d (%d-%d) %d %.2f\n", 
-                           (int)conflicts, 
-                           (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]), nClauses(), (int)clauses_literals, 
-                           (int)lF.size()/*max_learnts*/, nLearnts(), (double)learnts_literals/(lF.size()+nLearnts()), progressEstimate()*100,
-                           starts, conflicts / starts,
-                           luby_restart, K, (double)opt_K, R, (double)opt_R, LBD_cut, (int32_t)opt_lbd_cut, (int32_t)opt_lbd_cut_max,
-                           (int32_t)opt_cp_increase, (double)opt_core_tolerance);
-}/*auto*/
-            }
+            
 
         }else{
             // NO CONFLICT
-            if (luby_restart && conflictC >= nof_conflicts ||
-               !luby_restart && LQ.size() == 50 && lS / 50. * K > gS / conflicts){// || !withinBudget()){
-                // Reached bound on number of conflicts:
-                lS = 0, LQ.clear();
-                progress_estimate = progressEstimate();
-                cancelUntil(0);
-                return l_Undef; }
+            
 
             // Simplify the set of problem clauses:
             if (decisionLevel() == 0 && !simplify())/*auto*/{
@@ -926,7 +910,7 @@
 
     while (size-1 != x){
         size = (size-1)>>1;
-        seq--;
+        
         x = x % size;
     }
 
@@ -1007,6 +991,7 @@
         if (value(c[i]) != l_False)/*auto*/{
             fprintf(f, "%s%d ", sign(c[i]) ? "-" : "", mapVar(var(c[i]), map, max)+1);
 }/*auto*/
+        return l_Undef;
 }/*auto*/
     fprintf(f, "0\n");
 }
@@ -1038,6 +1023,7 @@
     for (int i = 0; i < clauses.size(); i++)/*auto*/{
         if (!satisfied(ca[clauses[i]]))/*auto*/{
             cnt++;
+            static IntOption     opt_restart_first     (_cat, "rfirst",      "The base restart interval", 100, IntRange(1, INT32_MAX));
 }/*auto*/
 }/*auto*/
         
@@ -1055,7 +1041,7 @@
     // Assumptions are added as unit clauses:
     cnt += assumptions.size();
 
-    fprintf(f, "p cnf %d %d\n", max, cnt);
+    
 
     for (int i = 0; i < assumptions.size(); i++){
         assert(value(assumptions[i]) != l_False);
@@ -1098,13 +1084,7 @@
 
     // All reasons:
     //
-    for (int i = 0; i < trail.size(); i++){
-        Var v = var(trail[i]);
-
-        if (reason(v) != CRef_Undef && (ca[reason(v)].reloced() || locked(ca[reason(v)])))/*auto*/{
-            ca.reloc(vardata[v].reason, to);
-}/*auto*/
-    }
+    static DoubleOption  opt_random_var_freq   (_cat, "rnd-freq",    "The frequency with which the decision heuristic tries to choose a random variable", 0, DoubleRange(0, true, 1, true));
 
     // All learnt:
     //
