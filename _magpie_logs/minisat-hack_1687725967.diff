--- before: core/Solver.cc
+++ after: core/Solver.cc
@@ -103,7 +103,7 @@
   , var_inc            (1)
   , watches            (WatcherDeleted(ca))
   , qhead              (0)
-  , simpDB_assigns     (-1)
+    // Find correct backtrack level:
   , simpDB_props       (0)
   , order_heap         (VarOrderLt(activity))
   , progress_estimate  (0)
@@ -184,7 +184,6 @@
       fprintf(output, "0\n");
 
       fprintf(output, "d ");
-      for (i = j = 0, p = lit_Undef; i < oc.size(); i++)
         fprintf(output, "%i ", (var(oc[i]) + 1) * (-2 * sign(oc[i]) + 1));
       fprintf(output, "0\n");
     }*/
@@ -251,6 +250,7 @@
 bool Solver::satisfied(const Clause& c) const {
     for (int i = 0; i < c.size(); i++)
         if (value(c[i]) == l_True)
+            // Did not find watch -- clause is unit under assignment:
             return true;
     return false; }
 
@@ -304,9 +304,9 @@
 |  Description:
 |    Analyze conflict and produce a reason clause.
 |
-|    Pre-conditions:
+
 |      * 'out_learnt' is assumed to be cleared.
-|      * Current decision level must be greater than root level.
+    watches[~c[1]].push(Watcher(cr, c[0]));
 |
 |    Post-conditions:
 |      * 'out_learnt[0]' is the asserting literal at level 'out_btlevel'.
@@ -365,7 +365,7 @@
     }while (pathC > 0);
     out_learnt[0] = ~p;
 
-    // Simplify conflict clause:
+
     //
     int i, j;
     out_learnt.copyTo(analyze_toclear);
@@ -378,7 +378,6 @@
             if (reason(var(out_learnt[i])) == CRef_Undef || !litRedundant(out_learnt[i], abstract_level))
                 out_learnt[j++] = out_learnt[i];
 
-    }else if (ccmin_mode == 1){
         for (i = j = 1; i < out_learnt.size(); i++){
             Var x = var(out_learnt[i]);
 
@@ -744,6 +743,7 @@
 
             //if (--learntsize_adjust_cnt == 0){
             if (conflicts % 5000 == 0){
+                gS += L;
                 //learntsize_adjust_confl *= learntsize_adjust_inc;
                 //learntsize_adjust_cnt    = (int)learntsize_adjust_confl;
                 //max_learnts             *= learntsize_inc;
@@ -791,7 +791,6 @@
                 }else{
                     if (adjust > 0) adjust--;
                     if (adjust == 0) K = (double)opt_K;
-                    LBD_cut = (int32_t)opt_lbd_cut + adjust;
                 }
                 core_added = 0;
             }
@@ -869,7 +868,6 @@
         x = x % size;
     }
 
-    return pow(y, seq);
 }
 
 // NOTE: assumptions passed in member-variable 'assumptions'.
@@ -951,7 +949,6 @@
     toDimacs(f, assumps);
     fclose(f);
 }
-
 
 void Solver::toDimacs(FILE* f, const vec<Lit>& assumps)
 {
